<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compile - P2P Card Game</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a0e2e 100%);
            color: #00ff88;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        #connection-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 40px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .hidden {
            display: none !important;
        }

        input, button {
            padding: 10px 20px;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            color: #00ff88;
            border: 1px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #game-board {
            width: 100%;
            max-width: 1400px;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            min-height: 90vh;
        }

        .player-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
        }

        .field {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 40px 20px 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            min-height: 400px;
            position: relative;
        }
        
        .field::before {
            content: 'BATTLEFIELD';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: #0a0e1a;
            padding: 0 10px;
            color: #00ff88;
            font-weight: bold;
            font-size: 14px;
        }

        .line {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            position: relative;
            padding: 0 5px;
            border-right: 1px solid rgba(0, 255, 136, 0.1);
        }
        
        .line:last-child {
            border-right: none;
        }

        .line-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            line-height: 1.3;
        }

        .protocol {
            width: 120px;
            height: 160px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, var(--card-bg1), var(--card-bg2));
        }

        .protocol.loading {
            background: linear-gradient(135deg, #444, #222);
            border: 2px solid #666;
            color: #888;
        }

        .protocol.compiled {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border: 2px solid #00ff88;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        
        .protocol.compiled::after {
            content: '✓';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 20px;
            color: #000;
        }

        .stack {
            min-height: 100px;
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: -30px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 5px;
            transition: all 0.3s;
        }
        
        .stack:hover {
            background: rgba(0, 255, 136, 0.05);
        }
        
        #my-stack-0::before,
        #my-stack-1::before,
        #my-stack-2::before {
            content: 'Your stack';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.1);
            font-size: 10px;
            pointer-events: none;
            z-index: 0;
        }
        
        #opp-stack-0::before,
        #opp-stack-1::before,
        #opp-stack-2::before {
            content: 'Opponent stack';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.1);
            font-size: 10px;
            pointer-events: none;
            z-index: 0;
        }
        
        .stack .card {
            z-index: 1;
        }

        .card {
            width: 100px;
            height: 140px;
            border-radius: 6px;
            border: 2px solid;
            display: flex;
            flex-direction: column;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            background: linear-gradient(135deg, var(--card-bg1), var(--card-bg2));
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stack .card {
            margin-top: -100px;
        }

        .stack .card:first-child {
            margin-top: 0;
        }

        .hand .card {
            margin-top: 0;
        }

        .stack .card.face-down .card-content {
            display: none;
        }
        
        .stack .card.face-down::after {
            content: '?';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #666;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .stack .card:last-child.face-down {
            cursor: context-menu;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.7);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-value {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .card-text {
            font-size: 10px;
            line-height: 1.3;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            color: #fff;
        }

        .card-text div {
            padding: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            font-size: 9px;
        }

        .card-text div strong {
            color: #fff;
            font-weight: bold;
        }

        .hand {
            display: flex;
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            min-height: 180px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .hand .card {
            margin-top: 0;
            cursor: pointer;
            position: relative;
        }

        .hand .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        
        .hand .card::after {
            content: '⚙';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            opacity: 0;
            color: #00ff88;
            transition: opacity 0.3s;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .hand .card:hover::after {
            opacity: 0.8;
        }

        .info-panel {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
        }

        .draft-area {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            margin: 20px 0;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .protocol-select {
            cursor: pointer;
            transition: all 0.3s;
        }

        .protocol-select:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .protocol-select.selected {
            opacity: 0.3;
            pointer-events: none;
        }

        #status {
            font-size: 18px;
            padding: 10px;
            text-align: center;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            margin: 10px 0;
        }

        .control-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ffaa00, #ff6600);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            animation: pulse 2s infinite;
        }

        .card.last-played {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
            animation: glow 2s ease-in-out infinite;
        }
        
        .card.last-played::after {
            content: 'NEW';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #00ff88;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.8); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 136, 1); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        
        #card-preview {
            animation: zoomIn 0.15s ease-out;
        }
        
        @keyframes zoomIn {
            from { 
                opacity: 0; 
                transform: scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        /* Protocol Colors - Applied to both cards and protocol headers */
        .protocol-chaos, .card.protocol-chaos { --card-bg1: #d946ef; --card-bg2: #a21caf; border-color: #d946ef; }
        .protocol-clarity, .card.protocol-clarity { --card-bg1: #94a3b8; --card-bg2: #64748b; border-color: #94a3b8; }
        .protocol-corruption, .card.protocol-corruption { --card-bg1: #65a30d; --card-bg2: #4d7c0f; border-color: #65a30d; }
        .protocol-courage, .card.protocol-courage { --card-bg1: #fb923c; --card-bg2: #ea580c; border-color: #fb923c; }
        .protocol-fear, .card.protocol-fear { --card-bg1: #f97316; --card-bg2: #c2410c; border-color: #f97316; }
        .protocol-gravity, .card.protocol-gravity { --card-bg1: #7c3aed; --card-bg2: #5b21b6; border-color: #7c3aed; }
        .protocol-ice, .card.protocol-ice { --card-bg1: #c084fc; --card-bg2: #9333ea; border-color: #c084fc; }
        .protocol-life, .card.protocol-life { --card-bg1: #14b8a6; --card-bg2: #0d9488; border-color: #14b8a6; }
        .protocol-light, .card.protocol-light { --card-bg1: #fdba74; --card-bg2: #f97316; border-color: #fdba74; }
        .protocol-luck, .card.protocol-luck { --card-bg1: #5eead4; --card-bg2: #2dd4bf; border-color: #5eead4; }
        .protocol-metal, .card.protocol-metal { --card-bg1: #9ca3af; --card-bg2: #6b7280; border-color: #9ca3af; }
        .protocol-mirror, .card.protocol-mirror { --card-bg1: #f43f5e; --card-bg2: #e11d48; border-color: #f43f5e; }
        .protocol-peace, .card.protocol-peace { --card-bg1: #fde047; --card-bg2: #facc15; border-color: #fde047; }
        .protocol-plague, .card.protocol-plague { --card-bg1: #10b981; --card-bg2: #059669; border-color: #10b981; }
        .protocol-psychic, .card.protocol-psychic { --card-bg1: #a855f7; --card-bg2: #7c3aed; border-color: #a855f7; }
        .protocol-smoke, .card.protocol-smoke { --card-bg1: #14b8a6; --card-bg2: #0d9488; border-color: #14b8a6; }
        .protocol-speed, .card.protocol-speed { --card-bg1: #94a3b8; --card-bg2: #64748b; border-color: #94a3b8; }
        .protocol-spirit, .card.protocol-spirit { --card-bg1: #3b82f6; --card-bg2: #1e40af; border-color: #3b82f6; }
        .protocol-time, .card.protocol-time { --card-bg1: #f87171; --card-bg2: #dc2626; border-color: #f87171; }
        .protocol-war, .card.protocol-war { --card-bg1: #7f1d1d; --card-bg2: #450a0a; border-color: #7f1d1d; }
        .protocol-water, .card.protocol-water { --card-bg1: #3b82f6; --card-bg2: #1e40af; border-color: #3b82f6; }
    </style>
</head>
<body>
    <div id="connection-screen">
        <h1>COMPILE</h1>
        <p>Competitive P2P Card Game</p>
        <div>
            <label>Your ID: </label>
            <input type="text" id="my-id" readonly>
            <button onclick="copyId()">Copy</button>
        </div>
        <div>
            <label>Connect to: </label>
            <input type="text" id="peer-id" placeholder="Enter peer ID">
            <button onclick="connectToPeer()">Connect</button>
        </div>
        <div id="connection-status"></div>
        <div style="margin-top: 20px; font-size: 12px; opacity: 0.7;">
            <p>Having connection issues?</p>
            <button onclick="useLocalMode()">Play Local Mode (Same Browser)</button>
        </div>
    </div>

    <div id="draft-screen" class="hidden">
        <h2>PROTOCOL DRAFT</h2>
        <div id="status"></div>
        <div style="text-align: center; margin: 10px;">
            <div style="opacity: 0.8;">
                <small>Draft Order: Player 1 picks 1 → Player 2 picks 2 → Player 1 picks 2 → Player 2 picks 1</small>
            </div>
            <div style="margin-top: 5px; color: #00ff88;">
                <small id="player-role"></small>
            </div>
        </div>
        <div id="draft-area" class="draft-area"></div>
        <div id="selected-protocols">
            <h3>Your Protocols:</h3>
            <div id="my-protocols"></div>
        </div>
    </div>

    <div id="game-board" class="hidden">
        <div style="text-align: center; margin-bottom: 10px;">
            <small style="color: #00ff88; opacity: 0.8;">
                Right-click any top card in a stack to: Flip • Discard • Return to hand • Move • Delete
            </small>
        </div>
        <div class="player-area" id="opponent-area">
            <div class="info-panel">
                <span>Opponent</span>
                <span>Hand: <span id="opp-hand-count">5</span></span>
                <span>Deck: <span id="opp-deck-count">13</span></span>
                <span>Trash: <span id="opp-trash-count">0</span></span>
            </div>
        </div>

        <div class="field" id="field">
            <div class="line" data-line="0">
                <div class="line-label">Line 1</div>
                <div class="protocol loading" id="opp-protocol-0">Loading...</div>
                <div class="stack" id="opp-stack-0"></div>
                <div class="stack" id="my-stack-0"></div>
                <div class="protocol loading" id="my-protocol-0">Loading...</div>
            </div>
            <div class="line" data-line="1">
                <div class="line-label">Line 2</div>
                <div class="protocol loading" id="opp-protocol-1">Loading...</div>
                <div class="stack" id="opp-stack-1"></div>
                <div class="stack" id="my-stack-1"></div>
                <div class="protocol loading" id="my-protocol-1">Loading...</div>
            </div>
            <div class="line" data-line="2">
                <div class="line-label">Line 3</div>
                <div class="protocol loading" id="opp-protocol-2">Loading...</div>
                <div class="stack" id="opp-stack-2"></div>
                <div class="stack" id="my-stack-2"></div>
                <div class="protocol loading" id="my-protocol-2">Loading...</div>
            </div>
        </div>

        <div class="player-area" id="my-area">
            <div class="info-panel">
                <span style="font-weight: bold; color: #00ff88;">YOUR AREA</span>
                <span>Hand: <span id="my-hand-count">5</span></span>
                <span>Deck: <span id="my-deck-count">13</span></span>
                <span>Trash: <span id="my-trash-count">0</span></span>
                <span id="turn-indicator">Your Turn</span>
            </div>
            <div style="color: #00ff88; text-align: center; margin: 10px 0;">
                YOUR HAND <small style="opacity: 0.7;">(Left-click to play • Right-click for options)</small>
            </div>
            <div class="hand" id="my-hand">
                <div style="color: #666; font-style: italic;">Cards will appear here after draft</div>
            </div>
            <div class="action-buttons">
                <button onclick="refreshHand()" id="refresh-btn">Refresh Hand</button>
                <button onclick="countValues()" id="count-btn" title="Count the current values in each line">Count Values</button>
                <button onclick="endTurn()" id="end-turn-btn">End Turn</button>
            </div>
        </div>
    </div>

    <script>
        // Protocol definitions with command cards
        const PROTOCOLS = {
            chaos: { color: '#d946ef', commands: generateCommands('chaos') },
            clarity: { color: '#94a3b8', commands: generateCommands('clarity') },
            corruption: { color: '#65a30d', commands: generateCommands('corruption') },
            courage: { color: '#fb923c', commands: generateCommands('courage') },
            fear: { color: '#f97316', commands: generateCommands('fear') },
            gravity: { color: '#7c3aed', commands: generateCommands('gravity') },
            ice: { color: '#c084fc', commands: generateCommands('ice') },
            life: { color: '#14b8a6', commands: generateCommands('life') },
            light: { color: '#fdba74', commands: generateCommands('light') },
            luck: { color: '#5eead4', commands: generateCommands('luck') },
            metal: { color: '#9ca3af', commands: generateCommands('metal') },
            mirror: { color: '#f43f5e', commands: generateCommands('mirror') },
            peace: { color: '#fde047', commands: generateCommands('peace') },
            plague: { color: '#10b981', commands: generateCommands('plague') },
            psychic: { color: '#a855f7', commands: generateCommands('psychic') },
            smoke: { color: '#14b8a6', commands: generateCommands('smoke') },
            speed: { color: '#94a3b8', commands: generateCommands('speed') },
            spirit: { color: '#3b82f6', commands: generateCommands('spirit') },
            time: { color: '#f87171', commands: generateCommands('time') },
            war: { color: '#7f1d1d', commands: generateCommands('war') },
            water: { color: '#3b82f6', commands: generateCommands('water') }
        };

        function generateCommands(protocol) {
            const commands = [];
            const effects = [
                { top: 'Start:', mid: 'Draw 1 card', bot: 'End: +1 value' },
                { top: 'Persistent', mid: 'Flip 1 card', bot: 'Discard 1 card' },
                { top: 'While active', mid: 'Shift 1 card', bot: 'Return 1 card' },
                { top: 'Start: Draw', mid: 'Delete 1 card', bot: 'Compile +2' },
                { top: 'Always', mid: 'Reveal hand', bot: 'Draw 2, discard 1' },
                { top: 'Control', mid: 'Rearrange', bot: 'End: Refresh' }
            ];
            
            for (let i = 0; i < 6; i++) {
                commands.push({
                    protocol: protocol,
                    value: i,
                    topText: effects[i].top,
                    middleText: effects[i].mid,
                    bottomText: effects[i].bot
                });
            }
            return commands;
        }

        // Game state
        let peer = null;
        let conn = null;
        let gameState = {
            phase: 'connecting',
            myProtocols: [],
            opponentProtocols: [],
            myDeck: [],
            myHand: [],
            myTrash: [],
            opponentHandCount: 5,
            opponentDeckCount: 13,
            opponentTrashCount: 0,
            field: [
                { oppStack: [], myStack: [] },
                { oppStack: [], myStack: [] },
                { oppStack: [], myStack: [] }
            ],
            currentTurn: null,
            isHost: false,
            hasControl: false,
            draftOrder: [],
            currentDraftPick: 0
        };

        function copyId() {
            const idInput = document.getElementById('my-id');
            idInput.select();
            document.execCommand('copy');
            
            const status = document.getElementById('connection-status');
            const oldText = status.textContent;
            status.textContent = 'ID copied to clipboard!';
            status.style.color = '#00ff88';
            
            setTimeout(() => {
                status.textContent = oldText;
            }, 2000);
        }

        function useLocalMode() {
            // Simulate a connection for local play
            document.getElementById('connection-status').textContent = 'Starting local mode...';
            document.getElementById('connection-status').style.color = '#00ff88';
            
            // Create a mock connection
            conn = {
                send: (data) => {
                    // In local mode, handle both sides
                    if (data.type === 'startGame') {
                        // Simulate receiving the start game message
                        setTimeout(() => {
                            gameState.opponentProtocols = data.opponentProtocols;
                            gameState.currentTurn = data.firstPlayer === 'me' ? 'opponent' : 'me';
                        }, 100);
                    }
                },
                on: (event, callback) => {
                    // Store callbacks for local mode
                    if (!window.localCallbacks) window.localCallbacks = {};
                    window.localCallbacks[event] = callback;
                }
            };
            
            gameState.isHost = true;
            gameState.isLocalMode = true;
            
            setTimeout(() => {
                document.getElementById('connection-screen').classList.add('hidden');
                startDraft();
            }, 1000);
        }

        function handleLocalMessage(data) {
            // In local mode, simulate opponent actions
            switch(data.type) {
                case 'startDraft':
                    // Auto-pick for opponent in local mode
                    setTimeout(() => autoPickForOpponent(), 2000);
                    break;
                case 'playCard':
                    // Mirror the play for local testing
                    break;
                // Add more local mode handlers as needed
            }
        }

        function autoPickForOpponent() {
            // Simulate opponent picking in local mode
            const availableProtocols = gameState.draftOrder.filter(p => 
                !gameState.myProtocols.includes(p) && 
                !gameState.opponentProtocols.includes(p)
            );
            
            const pickOrder = [1, 2, 2, 1]; // Correct draft order
            const pickCount = pickOrder[gameState.currentDraftPick] || 0;
            
            // Check if it's opponent's turn
            const isOpponentTurn = (gameState.currentDraftPick === 1) || (gameState.currentDraftPick === 3);
            
            if (isOpponentTurn && availableProtocols.length >= pickCount) {
                const picks = availableProtocols.slice(0, pickCount);
                handleOpponentDraftPick(picks);
            }
        }

        // Initialize PeerJS
        function initPeer() {
            try {
                // Generate random ID if needed
                const randomId = 'compile-' + Math.random().toString(36).substr(2, 9);
                
                peer = new Peer(randomId, {
                    debug: 2, // Set debug level for better error messages
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('open', (id) => {
                    console.log('Peer opened with ID:', id);
                    document.getElementById('my-id').value = id;
                    document.getElementById('connection-status').textContent = 'Ready! Share your ID with another player.';
                    document.getElementById('connection-status').style.color = '#00ff88';
                });

                peer.on('connection', (connection) => {
                    console.log('Incoming connection');
                    conn = connection;
                    gameState.isHost = true;
                    setupConnection();
                });

                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    let errorMsg = 'Connection error: ';
                    
                    if (err.type === 'network') {
                        errorMsg += 'Network error. Check your internet connection.';
                    } else if (err.type === 'peer-unavailable') {
                        errorMsg += 'Peer ID not found. Check the ID and try again.';
                    } else if (err.type === 'browser-incompatible') {
                        errorMsg += 'Browser not compatible. Try Chrome, Firefox, or Edge.';
                    } else if (err.type === 'server-error') {
                        errorMsg += 'Server error. Try refreshing the page or use Local Mode.';
                    } else if (err.type === 'unavailable-id') {
                        errorMsg += 'ID already taken. Refreshing...';
                        setTimeout(() => initPeer(), 1000);
                        return;
                    } else {
                        errorMsg += (err.message || 'Unknown error occurred.') + ' Try Local Mode instead.';
                    }
                    
                    document.getElementById('connection-status').textContent = errorMsg;
                    document.getElementById('connection-status').style.color = '#ff4444';
                });
                
                peer.on('disconnected', () => {
                    console.log('Peer disconnected');
                    document.getElementById('connection-status').textContent = 'Disconnected. Attempting to reconnect...';
                    document.getElementById('connection-status').style.color = '#ffaa00';
                    
                    // Try to reconnect
                    if (peer && !peer.destroyed) {
                        peer.reconnect();
                    }
                });
                
                peer.on('close', () => {
                    console.log('Peer connection closed');
                    document.getElementById('connection-status').textContent = 'Connection closed.';
                    document.getElementById('connection-status').style.color = '#ff4444';
                });
                
            } catch (err) {
                console.error('Failed to initialize peer:', err);
                document.getElementById('connection-status').textContent = 
                    'Failed to initialize connection. Try using Local Mode or refresh the page.';
                document.getElementById('connection-status').style.color = '#ff4444';
            }
        }

        function connectToPeer() {
            const peerId = document.getElementById('peer-id').value.trim();
            if (!peerId) {
                document.getElementById('connection-status').textContent = 'Please enter a peer ID';
                document.getElementById('connection-status').style.color = '#ffaa00';
                return;
            }

            document.getElementById('connection-status').textContent = 'Connecting...';
            document.getElementById('connection-status').style.color = '#ffaa00';
            
            try {
                conn = peer.connect(peerId, {
                    reliable: true,
                    serialization: 'json'
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    document.getElementById('connection-status').textContent = 'Failed to connect. Check the ID and try again.';
                    document.getElementById('connection-status').style.color = '#ff4444';
                });
                
                setupConnection();
            } catch (err) {
                console.error('Failed to connect:', err);
                document.getElementById('connection-status').textContent = 'Connection failed: ' + err.message;
                document.getElementById('connection-status').style.color = '#ff4444';
            }
        }

        function setupConnection() {
            conn.on('open', () => {
                document.getElementById('connection-status').textContent = 'Connected!';
                setTimeout(() => {
                    document.getElementById('connection-screen').classList.add('hidden');
                    if (gameState.isHost) {
                        startDraft();
                    }
                }, 1000);
            });

            conn.on('data', (data) => {
                handleMessage(data);
            });

            conn.on('close', () => {
                alert('Connection lost!');
                location.reload();
            });
        }

        function handleMessage(data) {
            switch(data.type) {
                case 'startDraft':
                    gameState.draftOrder = data.order;
                    gameState.currentDraftPick = data.currentPick;
                    showDraft();
                    break;
                case 'draftPick':
                    handleOpponentDraftPick(data.protocols);
                    break;
                case 'startGame':
                    gameState.opponentProtocols = data.opponentProtocols;
                    gameState.currentTurn = data.firstPlayer;
                    startGame();
                    break;
                case 'playCard':
                    handleOpponentPlayCard(data);
                    break;
                case 'refreshHand':
                    gameState.opponentHandCount = 5;
                    updateUI();
                    break;
                case 'endTurn':
                    gameState.currentTurn = 'me';
                    // Clear last played card after a delay
                    setTimeout(() => {
                        lastPlayedCard = null;
                        updateUI();
                    }, 3000);
                    updateUI();
                    break;
                case 'compileLine':
                    handleOpponentCompile(data.lineIndex);
                    break;
                case 'cardAction':
                    handleOpponentCardAction(data);
                    break;
                case 'handDiscard':
                    gameState.opponentHandCount--;
                    gameState.opponentTrashCount++;
                    showMessage('Opponent discarded a card from hand!', 'info');
                    updateUI();
                    break;
                case 'gameState':
                    syncGameState(data.state);
                    break;
            }
        }
        
        function handleOpponentCardAction(data) {
            const { action, lineIndex, stackIndex, isOpponent, fromLine, toLine } = data;
            
            // Note: isOpponent is from sender's perspective, so we flip it
            const stack = isOpponent ? gameState.field[lineIndex].myStack : gameState.field[lineIndex].oppStack;
            
            switch(action) {
                case 'flip':
                    if (stack[stackIndex]) {
                        stack[stackIndex].faceDown = !stack[stackIndex].faceDown;
                        lastPlayedCard = {
                            lineIndex: lineIndex,
                            stackIndex: stackIndex,
                            isOpponent: !isOpponent
                        };
                        showMessage('Opponent flipped a card!', 'info');
                    }
                    break;
                case 'discard':
                    if (stack[stackIndex]) {
                        stack.splice(stackIndex, 1);
                        gameState.opponentTrashCount++;
                        showMessage('Opponent discarded a card!', 'info');
                    }
                    break;
                case 'return':
                    if (stack[stackIndex]) {
                        stack.splice(stackIndex, 1);
                        gameState.opponentHandCount++;
                        showMessage('Opponent returned a card to hand!', 'info');
                    }
                    break;
                case 'delete':
                    if (stack[stackIndex]) {
                        stack.splice(stackIndex, 1);
                        gameState.opponentTrashCount++;
                        showMessage('Opponent deleted a card!', 'info');
                    }
                    break;
                case 'move':
                    const fromStack = isOpponent ? gameState.field[fromLine].myStack : gameState.field[fromLine].oppStack;
                    const toStack = isOpponent ? gameState.field[toLine].myStack : gameState.field[toLine].oppStack;
                    if (fromStack[stackIndex]) {
                        const card = fromStack.splice(stackIndex, 1)[0];
                        toStack.push(card);
                        lastPlayedCard = {
                            lineIndex: toLine,
                            stackIndex: toStack.length - 1,
                            isOpponent: !isOpponent
                        };
                        showMessage(`Opponent moved a card to line ${toLine + 1}!`, 'info');
                    }
                    break;
            }
            
            updateUI();
        }
        
        function handleOpponentCompile(lineIndex) {
            // Delete all cards in this line
            gameState.field[lineIndex].myStack = [];
            gameState.field[lineIndex].oppStack = [];
            
            // Mark opponent protocol as compiled
            const oppProtocol = document.getElementById(`opp-protocol-${lineIndex}`);
            oppProtocol.classList.remove('loading');
            oppProtocol.classList.add('compiled');
            
            showMessage(`Opponent compiled ${gameState.opponentProtocols[lineIndex]}!`, 'info');
            
            // Check if opponent won
            const oppCompiledCount = document.querySelectorAll('.protocol.compiled#opp-protocol-0, .protocol.compiled#opp-protocol-1, .protocol.compiled#opp-protocol-2').length;
            
            if (oppCompiledCount === 3) {
                showMessage('Opponent wins! They compiled all protocols!', 'error');
                document.getElementById('turn-indicator').textContent = 'DEFEAT';
                document.getElementById('turn-indicator').style.color = '#ff4444';
                document.getElementById('refresh-btn').disabled = true;
                document.getElementById('end-turn-btn').disabled = true;
                document.getElementById('count-btn').disabled = true;
            }
            
            updateUI();
        }

        function startDraft() {
            const protocols = Object.keys(PROTOCOLS);
            const shuffled = protocols.sort(() => Math.random() - 0.5);
            gameState.draftOrder = shuffled.slice(0, 12); // Show 12 protocols for drafting
            gameState.currentDraftPick = 0;
            
            conn.send({
                type: 'startDraft',
                order: gameState.draftOrder,
                currentPick: 0
            });
            
            showDraft();
        }

        function showDraft() {
            document.getElementById('draft-screen').classList.remove('hidden');
            // Show player role
            const playerRole = document.getElementById('player-role');
            if (playerRole) {
                playerRole.textContent = gameState.isHost ? 'You are Player 1 (drafting first)' : 'You are Player 2';
            }
            updateDraftUI();
        }

        function updateDraftUI() {
            const draftArea = document.getElementById('draft-area');
            draftArea.innerHTML = '';
            
            gameState.draftOrder.forEach((protocol, index) => {
                const protocolDiv = document.createElement('div');
                protocolDiv.className = `protocol protocol-${protocol} protocol-select`;
                protocolDiv.textContent = protocol.toUpperCase();
                protocolDiv.onclick = () => selectProtocol(protocol);
                
                // Mark as selected if already picked
                if (gameState.myProtocols.includes(protocol) || 
                    gameState.opponentProtocols.includes(protocol)) {
                    protocolDiv.classList.add('selected');
                }
                
                draftArea.appendChild(protocolDiv);
            });
            
            // Update status
            const status = document.getElementById('status');
            const pickOrder = [1, 2, 2, 1]; // Correct draft order: P1-1, P2-2, P1-2, P2-1
            const currentPickCount = pickOrder[gameState.currentDraftPick] || 0;
            
            if (gameState.currentDraftPick >= 4) {
                status.textContent = 'Draft complete! Starting game...';
                setTimeout(() => finalizeDraft(), 2000);
            } else {
                const isMyTurn = (gameState.currentDraftPick === 0 && gameState.isHost) ||
                                 (gameState.currentDraftPick === 1 && !gameState.isHost) ||
                                 (gameState.currentDraftPick === 2 && gameState.isHost) ||
                                 (gameState.currentDraftPick === 3 && !gameState.isHost);
                status.textContent = isMyTurn ? 
                    `Your turn - Pick ${currentPickCount} protocol(s)` : 
                    'Waiting for opponent...';
                    
                // In local mode, auto-pick for opponent
                if (gameState.isLocalMode && !isMyTurn) {
                    setTimeout(() => autoPickForOpponent(), 1500);
                }
            }
            
            // Update selected protocols display
            document.getElementById('my-protocols').textContent = 
                gameState.myProtocols.join(', ').toUpperCase() || 'None';
        }

        function selectProtocol(protocol) {
            const pickOrder = [1, 2, 2, 1]; // Correct draft order: P1-1, P2-2, P1-2, P2-1
            const currentPickCount = pickOrder[gameState.currentDraftPick] || 0;
            const isMyTurn = (gameState.currentDraftPick === 0 && gameState.isHost) ||
                             (gameState.currentDraftPick === 1 && !gameState.isHost) ||
                             (gameState.currentDraftPick === 2 && gameState.isHost) ||
                             (gameState.currentDraftPick === 3 && !gameState.isHost);
            
            if (!isMyTurn) return;
            if (gameState.myProtocols.includes(protocol)) return;
            if (gameState.opponentProtocols.includes(protocol)) return;
            
            // Temporarily store picks
            if (!gameState.tempPicks) gameState.tempPicks = [];
            
            // Toggle selection if picking multiple
            if (currentPickCount > 1) {
                const index = gameState.tempPicks.indexOf(protocol);
                if (index > -1) {
                    gameState.tempPicks.splice(index, 1);
                    document.querySelector(`.protocol-${protocol}`).style.border = '';
                } else if (gameState.tempPicks.length < currentPickCount) {
                    gameState.tempPicks.push(protocol);
                    document.querySelector(`.protocol-${protocol}`).style.border = '3px solid #00ff88';
                }
                
                // Update status to show selection progress
                const status = document.getElementById('status');
                status.textContent = `Pick ${currentPickCount} protocols (${gameState.tempPicks.length}/${currentPickCount} selected)`;
                
                // Auto-submit when enough selected
                if (gameState.tempPicks.length === currentPickCount) {
                    setTimeout(() => {
                        // Complete the pick
                        gameState.myProtocols.push(...gameState.tempPicks);
                        
                        conn.send({
                            type: 'draftPick',
                            protocols: gameState.tempPicks
                        });
                        
                        // Clear temp selections
                        gameState.tempPicks.forEach(p => {
                            document.querySelector(`.protocol-${p}`).style.border = '';
                        });
                        
                        gameState.tempPicks = [];
                        gameState.currentDraftPick++;
                        updateDraftUI();
                    }, 500);
                }
            } else {
                // Single selection - immediate
                gameState.tempPicks.push(protocol);
                gameState.myProtocols.push(...gameState.tempPicks);
                
                conn.send({
                    type: 'draftPick',
                    protocols: gameState.tempPicks
                });
                
                gameState.tempPicks = [];
                gameState.currentDraftPick++;
                updateDraftUI();
            }
        }

        function handleOpponentDraftPick(protocols) {
            gameState.opponentProtocols.push(...protocols);
            gameState.currentDraftPick++;
            updateDraftUI();
        }

        function finalizeDraft() {
            console.log('Finalizing draft with protocols:', gameState.myProtocols);
            
            // Create deck from selected protocols
            gameState.myDeck = [];
            gameState.myProtocols.forEach(protocol => {
                const commands = PROTOCOLS[protocol].commands;
                console.log(`Adding ${commands.length} cards for ${protocol}`);
                gameState.myDeck.push(...commands);
            });
            
            // Shuffle the deck
            gameState.myDeck = shuffle(gameState.myDeck);
            console.log('Total deck size:', gameState.myDeck.length);
            
            // Draw starting hand
            gameState.myHand = gameState.myDeck.splice(0, 5);
            console.log('Starting hand:', gameState.myHand);
            
            // Set up opponent deck counts
            gameState.opponentDeckCount = 13;
            gameState.opponentHandCount = 5;
            
            // Determine first player
            if (gameState.isHost || gameState.isLocalMode) {
                gameState.currentTurn = Math.random() < 0.5 ? 'me' : 'opponent';
                if (conn && conn.send && !gameState.isLocalMode) {
                    conn.send({
                        type: 'startGame',
                        opponentProtocols: gameState.myProtocols,
                        firstPlayer: gameState.currentTurn === 'me' ? 'opponent' : 'me'
                    });
                } else if (gameState.isLocalMode) {
                    // In local mode, just set the opponent protocols
                    if (gameState.opponentProtocols.length === 0) {
                        // Pick remaining protocols for opponent in local mode
                        const remainingProtocols = gameState.draftOrder.filter(p => 
                            !gameState.myProtocols.includes(p)
                        );
                        gameState.opponentProtocols = remainingProtocols.slice(0, 3);
                    }
                }
            }
            
            document.getElementById('draft-screen').classList.add('hidden');
            startGame();
        }

        function startGame() {
            console.log('Starting game...');
            console.log('My hand:', gameState.myHand);
            console.log('My deck size:', gameState.myDeck.length);
            
            document.getElementById('game-board').classList.remove('hidden');
            
            // Ensure we have cards if not already dealt
            if (gameState.myHand.length === 0 && gameState.myDeck.length === 0) {
                console.log('No cards found, generating deck...');
                // Create deck from selected protocols if not already done
                gameState.myProtocols.forEach(protocol => {
                    gameState.myDeck.push(...PROTOCOLS[protocol].commands);
                });
                gameState.myDeck = shuffle(gameState.myDeck);
                gameState.myHand = gameState.myDeck.splice(0, 5);
            }
            
            updateUI();
        }

        function updateUI() {
            console.log('Updating UI - Hand size:', gameState.myHand.length);
            
            // Update protocols
            gameState.myProtocols.forEach((protocol, i) => {
                const elem = document.getElementById(`my-protocol-${i}`);
                if (elem) {
                    elem.textContent = protocol.toUpperCase();
                    elem.className = `protocol protocol-${protocol} loading`;
                }
            });
            
            gameState.opponentProtocols.forEach((protocol, i) => {
                const elem = document.getElementById(`opp-protocol-${i}`);
                if (elem) {
                    elem.textContent = protocol.toUpperCase();
                    elem.className = `protocol protocol-${protocol} loading`;
                }
            });
            
            // Update hand
            const handDiv = document.getElementById('my-hand');
            if (handDiv) {
                handDiv.innerHTML = '';
                if (gameState.myHand.length === 0) {
                    handDiv.innerHTML = '<div style="color: #666; font-style: italic;">No cards in hand</div>';
                } else {
                    gameState.myHand.forEach((card, index) => {
                        const cardElem = createCardElement(card, index, true);
                        handDiv.appendChild(cardElem);
                    });
                }
            }
            
            // Update stacks
            for (let i = 0; i < 3; i++) {
                updateStack(`my-stack-${i}`, gameState.field[i].myStack);
                updateStack(`opp-stack-${i}`, gameState.field[i].oppStack);
            }
            
            // Update counts
            document.getElementById('my-hand-count').textContent = gameState.myHand.length;
            document.getElementById('my-deck-count').textContent = gameState.myDeck.length;
            document.getElementById('my-trash-count').textContent = gameState.myTrash.length;
            document.getElementById('opp-hand-count').textContent = gameState.opponentHandCount;
            document.getElementById('opp-deck-count').textContent = gameState.opponentDeckCount;
            document.getElementById('opp-trash-count').textContent = gameState.opponentTrashCount;
            
            // Update turn indicator
            const turnIndicator = document.getElementById('turn-indicator');
            if (turnIndicator) {
                turnIndicator.textContent = gameState.currentTurn === 'me' ? 'Your Turn' : "Opponent's Turn";
                turnIndicator.style.color = gameState.currentTurn === 'me' ? '#00ff88' : '#ff4444';
            }
            
            // Enable/disable buttons
            const isMyTurn = gameState.currentTurn === 'me';
            const refreshBtn = document.getElementById('refresh-btn');
            const endTurnBtn = document.getElementById('end-turn-btn');
            const countBtn = document.getElementById('count-btn');
            if (refreshBtn) refreshBtn.disabled = !isMyTurn || gameState.myHand.length >= 5;
            if (endTurnBtn) endTurnBtn.disabled = !isMyTurn;
            if (countBtn) countBtn.disabled = false; // Always allow counting
            
            // Update compile buttons based on turn
            checkCompileConditions();
        }

        function createCardElement(card, index, inHand = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card protocol-${card.protocol}`;
            
            const content = `
                <div class="card-content">
                    <div class="card-header">
                        <span style="text-transform: uppercase; font-size: 10px;">${card.protocol}</span>
                        <span class="card-value">${card.value}</span>
                    </div>
                    <div class="card-text">
                        <div style="font-size: 8px; opacity: 0.9;">${card.topText}</div>
                        <div style="background: rgba(255,255,255,0.1);"><strong>${card.middleText}</strong></div>
                        <div style="font-size: 8px; opacity: 0.9;">${card.bottomText}</div>
                    </div>
                </div>
            `;
            cardDiv.innerHTML = content;
            
            if (inHand) {
                cardDiv.onclick = () => selectCard(index);
                cardDiv.oncontextmenu = (e) => showHandCardMenu(e, index);
                cardDiv.title = 'Left-click to play, right-click for options';
                
                // Add hover zoom preview for hand cards
                cardDiv.onmouseenter = (e) => showCardPreview(e, card);
                cardDiv.onmouseleave = () => hideCardPreview();
            }
            
            return cardDiv;
        }
        
        function showHandCardMenu(e, handIndex) {
            e.preventDefault();
            
            // Remove any existing context menu
            const existing = document.getElementById('context-menu');
            if (existing) existing.remove();
            
            if (gameState.currentTurn !== 'me') {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const card = gameState.myHand[handIndex];
            if (!card) return;
            
            const menu = document.createElement('div');
            menu.id = 'context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.pageX}px;
                top: ${e.pageY}px;
                background: rgba(0, 0, 0, 0.95);
                border: 1px solid #00ff88;
                border-radius: 5px;
                padding: 0;
                z-index: 1000;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            `;
            
            // Play card option
            const playBtn = document.createElement('button');
            playBtn.textContent = 'Play Card';
            playBtn.style.cssText = `
                display: block;
                width: 100%;
                padding: 8px 15px;
                background: transparent;
                color: #00ff88;
                border: none;
                text-align: left;
                cursor: pointer;
                font-family: inherit;
                font-size: 12px;
                transition: all 0.2s;
            `;
            playBtn.onmouseover = () => playBtn.style.background = 'rgba(0, 255, 136, 0.2)';
            playBtn.onmouseout = () => playBtn.style.background = 'transparent';
            playBtn.onclick = () => {
                menu.remove();
                selectCard(handIndex);
            };
            menu.appendChild(playBtn);
            
            // Discard option
            const discardBtn = document.createElement('button');
            discardBtn.textContent = 'Discard Card';
            discardBtn.style.cssText = `
                display: block;
                width: 100%;
                padding: 8px 15px;
                background: transparent;
                color: #ffaa00;
                border: none;
                text-align: left;
                cursor: pointer;
                font-family: inherit;
                font-size: 12px;
                transition: all 0.2s;
            `;
            discardBtn.onmouseover = () => discardBtn.style.background = 'rgba(255, 170, 0, 0.2)';
            discardBtn.onmouseout = () => discardBtn.style.background = 'transparent';
            discardBtn.onclick = () => {
                discardHandCard(handIndex);
                menu.remove();
            };
            menu.appendChild(discardBtn);
            
            // Cancel option
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                display: block;
                width: 100%;
                padding: 8px 15px;
                background: transparent;
                color: #ff4444;
                border: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                text-align: left;
                cursor: pointer;
                font-family: inherit;
                font-size: 12px;
            `;
            cancelBtn.onclick = () => menu.remove();
            menu.appendChild(cancelBtn);
            
            document.body.appendChild(menu);
            
            // Remove menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', function removeMenu() {
                    menu.remove();
                    document.removeEventListener('click', removeMenu);
                });
            }, 100);
        }
        
        function discardHandCard(handIndex) {
            const card = gameState.myHand.splice(handIndex, 1)[0];
            if (card) {
                gameState.myTrash.push(card);
                
                // Send action to opponent
                if (conn && conn.send) {
                    conn.send({
                        type: 'handDiscard'
                    });
                }
                
                showMessage('Card discarded from hand!', 'info');
                updateUI();
            }
        }

        function updateStack(stackId, cards) {
            const stackDiv = document.getElementById(stackId);
            if (!stackDiv) return;
            
            stackDiv.innerHTML = '';
            const isOpponentStack = stackId.includes('opp-stack');
            const lineIndex = parseInt(stackId.split('-')[2]);
            
            cards.forEach((card, index) => {
                const cardElem = createCardElement(card);
                if (card.faceDown) {
                    cardElem.classList.add('face-down');
                }
                
                // Check if this is the last played card
                if (lastPlayedCard && 
                    lastPlayedCard.lineIndex === lineIndex && 
                    lastPlayedCard.stackIndex === index &&
                    lastPlayedCard.isOpponent === isOpponentStack) {
                    cardElem.classList.add('last-played');
                }
                
                // Add right-click handler for all cards (menu will check if it's valid)
                cardElem.oncontextmenu = (e) => {
                    showCardContextMenu(e, lineIndex, index, isOpponentStack);
                };
                
                // Add hover zoom preview
                cardElem.onmouseenter = (e) => {
                    if (!card.faceDown) {
                        showCardPreview(e, card);
                    }
                };
                cardElem.onmouseleave = () => {
                    hideCardPreview();
                };
                
                // Add hover effect for top card only
                if (index === cards.length - 1) {
                    cardElem.style.cursor = 'context-menu';
                    cardElem.title = gameState.currentTurn === 'me' ? 
                        'Right-click for options' : 
                        'Wait for your turn to manipulate cards';
                }
                
                stackDiv.appendChild(cardElem);
            });
        }
        
        function showCardPreview(event, card) {
            // Remove any existing preview
            hideCardPreview();
            
            const preview = document.createElement('div');
            preview.id = 'card-preview';
            preview.className = `card protocol-${card.protocol}`;
            preview.style.cssText = `
                position: fixed;
                width: 200px;
                height: 280px;
                z-index: 2000;
                pointer-events: none;
                transform: scale(1);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
                border: 3px solid #00ff88;
                transition: none;
                background: linear-gradient(135deg, var(--card-bg1), var(--card-bg2));
            `;
            
            const content = `
                <div class="card-content" style="transform: scale(1.4); transform-origin: top left; padding: 10px;">
                    <div class="card-header">
                        <span style="text-transform: uppercase; font-size: 14px; font-weight: bold;">${card.protocol}</span>
                        <span class="card-value" style="font-size: 30px; font-weight: bold;">${card.value}</span>
                    </div>
                    <div class="card-text" style="margin-top: 10px;">
                        <div style="font-size: 12px; padding: 6px; margin: 4px 0; background: rgba(0,0,0,0.4); border-radius: 3px;">
                            <strong>PERSISTENT:</strong><br>${card.topText}
                        </div>
                        <div style="font-size: 13px; padding: 8px; margin: 6px 0; background: rgba(255,255,255,0.2); border-radius: 3px; border: 1px solid rgba(255,255,255,0.3);">
                            <strong>PLAY:</strong><br>${card.middleText}
                        </div>
                        <div style="font-size: 12px; padding: 6px; margin: 4px 0; background: rgba(0,0,0,0.4); border-radius: 3px;">
                            <strong>TRIGGER:</strong><br>${card.bottomText}
                        </div>
                    </div>
                </div>
            `;
            preview.innerHTML = content;
            
            // Position the preview
            const rect = event.target.getBoundingClientRect();
            const previewWidth = 200;
            const previewHeight = 280;
            const margin = 20;
            
            // Calculate available space
            const spaceRight = window.innerWidth - rect.right - margin;
            const spaceLeft = rect.left - margin;
            const spaceAbove = rect.top - margin;
            const spaceBelow = window.innerHeight - rect.bottom - margin;
            
            // Determine best position
            let left, top;
            
            if (spaceRight >= previewWidth) {
                // Show to the right
                left = rect.right + margin;
                top = Math.max(10, Math.min(rect.top - 50, window.innerHeight - previewHeight - 10));
            } else if (spaceLeft >= previewWidth) {
                // Show to the left
                left = rect.left - previewWidth - margin;
                top = Math.max(10, Math.min(rect.top - 50, window.innerHeight - previewHeight - 10));
            } else if (spaceAbove >= previewHeight) {
                // Show above
                left = Math.max(10, Math.min(rect.left, window.innerWidth - previewWidth - 10));
                top = rect.top - previewHeight - margin;
            } else {
                // Show below or best fit
                left = Math.max(10, Math.min(rect.left, window.innerWidth - previewWidth - 10));
                top = Math.min(rect.bottom + margin, window.innerHeight - previewHeight - 10);
            }
            
            preview.style.left = left + 'px';
            preview.style.top = top + 'px';
            
            document.body.appendChild(preview);
        }
        
        function hideCardPreview() {
            const preview = document.getElementById('card-preview');
            if (preview) {
                preview.remove();
            }
        }

        let selectedCard = null;
        let selectedCardIndex = null;
        let contextMenuCard = null;
        let lastPlayedCard = null; // Track last played card
        
        // Prevent default right-click menu
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.card')) {
                e.preventDefault();
            }
        });
        
        function selectCard(handIndex) {
            if (gameState.currentTurn !== 'me') {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const card = gameState.myHand[handIndex];
            if (!card) return;
            
            // Store selected card
            selectedCard = card;
            selectedCardIndex = handIndex;
            
            // Highlight selected card
            document.querySelectorAll('.hand .card').forEach((c, i) => {
                c.style.border = i === handIndex ? '3px solid #00ff88' : '';
            });
            
            // Show line selection UI
            showLineSelection();
        }
        
        function showCardContextMenu(e, lineIndex, stackIndex, isOpponent = false) {
            e.preventDefault();
            
            // Remove any existing context menu
            const existing = document.getElementById('context-menu');
            if (existing) existing.remove();
            
            if (gameState.currentTurn !== 'me') {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const stack = isOpponent ? gameState.field[lineIndex].oppStack : gameState.field[lineIndex].myStack;
            const card = stack[stackIndex];
            
            if (!card) return;
            
            // Can only manipulate uncovered cards (top of stack)
            const isUncovered = stackIndex === stack.length - 1;
            if (!isUncovered) {
                showMessage('Can only manipulate the top card of each stack!', 'error');
                return;
            }
            
            // Can't manipulate opponent's cards unless they're yours
            if (isOpponent && !card.isYours) {
                showMessage("Can't manipulate opponent's cards!", 'error');
                return;
            }
            
            const menu = document.createElement('div');
            menu.id = 'context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.pageX}px;
                top: ${e.pageY}px;
                background: rgba(0, 0, 0, 0.95);
                border: 1px solid #00ff88;
                border-radius: 5px;
                padding: 0;
                z-index: 1000;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            `;
            
            const options = [];
            
            // Flip option
            options.push({
                text: card.faceDown ? 'Flip Face-Up' : 'Flip Face-Down',
                action: () => flipCard(lineIndex, stackIndex, isOpponent)
            });
            
            // Discard option
            options.push({
                text: 'Discard Card',
                action: () => discardCard(lineIndex, stackIndex, isOpponent)
            });
            
            // Return to hand
            options.push({
                text: 'Return to Hand',
                action: () => returnToHand(lineIndex, stackIndex, isOpponent)
            });
            
            // Move to another line
            options.push({
                text: 'Move to Line...',
                action: () => showMoveOptions(lineIndex, stackIndex, isOpponent)
            });
            
            // Delete card (send to trash)
            options.push({
                text: 'Delete Card',
                action: () => deleteCard(lineIndex, stackIndex, isOpponent)
            });
            
            options.forEach(option => {
                const btn = document.createElement('button');
                btn.textContent = option.text;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 15px;
                    background: transparent;
                    color: #00ff88;
                    border: none;
                    text-align: left;
                    cursor: pointer;
                    font-family: inherit;
                    font-size: 12px;
                    transition: all 0.2s;
                `;
                btn.onmouseover = () => btn.style.background = 'rgba(0, 255, 136, 0.2)';
                btn.onmouseout = () => btn.style.background = 'transparent';
                btn.onclick = () => {
                    option.action();
                    menu.remove();
                };
                menu.appendChild(btn);
            });
            
            // Cancel option
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                display: block;
                width: 100%;
                padding: 8px 15px;
                background: transparent;
                color: #ff4444;
                border: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                text-align: left;
                cursor: pointer;
                font-family: inherit;
                font-size: 12px;
            `;
            cancelBtn.onclick = () => menu.remove();
            menu.appendChild(cancelBtn);
            
            document.body.appendChild(menu);
            
            // Remove menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', function removeMenu() {
                    menu.remove();
                    document.removeEventListener('click', removeMenu);
                });
            }, 100);
        }
        
        function flipCard(lineIndex, stackIndex, isOpponent) {
            const stack = isOpponent ? gameState.field[lineIndex].oppStack : gameState.field[lineIndex].myStack;
            const card = stack[stackIndex];
            
            if (!card) return;
            
            // Check if flipping face-up to correct protocol
            if (card.faceDown && !isOpponent) {
                const myProtocol = gameState.myProtocols[lineIndex];
                if (card.protocol !== myProtocol) {
                    showMessage(`Can't flip ${card.protocol} face-up in ${myProtocol} line!`, 'error');
                    return;
                }
            }
            
            card.faceDown = !card.faceDown;
            
            // Track as last action
            lastPlayedCard = {
                lineIndex: lineIndex,
                stackIndex: stackIndex,
                isOpponent: isOpponent
            };
            
            // Send action to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'cardAction',
                    action: 'flip',
                    lineIndex: lineIndex,
                    stackIndex: stackIndex,
                    isOpponent: !isOpponent // Reverse perspective for opponent
                });
            }
            
            showMessage(`Card ${card.faceDown ? 'flipped face-down' : 'revealed'}!`, 'info');
            updateUI();
        }
        
        function discardCard(lineIndex, stackIndex, isOpponent) {
            const stack = isOpponent ? gameState.field[lineIndex].oppStack : gameState.field[lineIndex].myStack;
            const card = stack[stackIndex];
            
            if (!card) return;
            
            // Remove from stack and add to hand (to discard later)
            stack.splice(stackIndex, 1);
            gameState.myTrash.push(card);
            
            // Send action to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'cardAction',
                    action: 'discard',
                    lineIndex: lineIndex,
                    stackIndex: stackIndex,
                    isOpponent: !isOpponent
                });
            }
            
            showMessage('Card discarded!', 'info');
            updateUI();
        }
        
        function returnToHand(lineIndex, stackIndex, isOpponent) {
            if (gameState.myHand.length >= 7) {
                showMessage('Hand is full! (max 7 cards)', 'error');
                return;
            }
            
            const stack = isOpponent ? gameState.field[lineIndex].oppStack : gameState.field[lineIndex].myStack;
            const card = stack[stackIndex];
            
            if (!card) return;
            
            // Remove from stack and add to hand
            stack.splice(stackIndex, 1);
            card.faceDown = false; // Cards in hand are always face-up
            gameState.myHand.push(card);
            
            // Send action to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'cardAction',
                    action: 'return',
                    lineIndex: lineIndex,
                    stackIndex: stackIndex,
                    isOpponent: !isOpponent
                });
            }
            
            showMessage('Card returned to hand!', 'info');
            updateUI();
        }
        
        function deleteCard(lineIndex, stackIndex, isOpponent) {
            const stack = isOpponent ? gameState.field[lineIndex].oppStack : gameState.field[lineIndex].myStack;
            const card = stack[stackIndex];
            
            if (!card) return;
            
            // Remove from stack and add to trash
            stack.splice(stackIndex, 1);
            gameState.myTrash.push(card);
            
            // Send action to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'cardAction',
                    action: 'delete',
                    lineIndex: lineIndex,
                    stackIndex: stackIndex,
                    isOpponent: !isOpponent
                });
            }
            
            showMessage('Card deleted!', 'info');
            updateUI();
        }
        
        function showMoveOptions(fromLine, stackIndex, isOpponent) {
            const modal = document.createElement('div');
            modal.className = 'move-modal';
            modal.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid #00ff88; border-radius: 10px;">
                    <h3>Move card to which line?</h3>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        ${[0, 1, 2].map(i => 
                            `<button onclick="moveCard(${fromLine}, ${stackIndex}, ${i}, ${isOpponent})" style="flex: 1;">
                                Line ${i + 1}<br><small>${gameState.myProtocols[i]}</small>
                            </button>`
                        ).join('')}
                        <button onclick="this.closest('.move-modal').remove()" style="flex: 1; background: rgba(255,0,0,0.2);">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1001;
            `;
            document.body.appendChild(modal);
        }
        
        function moveCard(fromLine, stackIndex, toLine, isOpponent) {
            if (fromLine === toLine) {
                showMessage('Card is already in that line!', 'error');
                document.querySelector('.move-modal')?.remove();
                return;
            }
            
            const fromStack = isOpponent ? gameState.field[fromLine].oppStack : gameState.field[fromLine].myStack;
            const toStack = isOpponent ? gameState.field[toLine].oppStack : gameState.field[toLine].myStack;
            const card = fromStack[stackIndex];
            
            if (!card) return;
            
            // Check if moving face-up card to correct protocol
            if (!card.faceDown && !isOpponent) {
                const targetProtocol = gameState.myProtocols[toLine];
                if (card.protocol !== targetProtocol) {
                    showMessage(`Can't move ${card.protocol} face-up to ${targetProtocol} line! Flip it face-down first.`, 'error');
                    document.querySelector('.move-modal')?.remove();
                    return;
                }
            }
            
            // Remove from old line and add to new line
            fromStack.splice(stackIndex, 1);
            toStack.push(card);
            
            // Track as last action (at new position)
            lastPlayedCard = {
                lineIndex: toLine,
                stackIndex: toStack.length - 1,
                isOpponent: isOpponent
            };
            
            // Send action to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'cardAction',
                    action: 'move',
                    fromLine: fromLine,
                    toLine: toLine,
                    stackIndex: stackIndex,
                    isOpponent: !isOpponent
                });
            }
            
            showMessage(`Card moved to line ${toLine + 1}!`, 'info');
            document.querySelector('.move-modal')?.remove();
            updateUI();
        }
        
        function showLineSelection() {
            // Highlight valid lines
            for (let i = 0; i < 3; i++) {
                const line = document.querySelector(`.line[data-line="${i}"]`);
                const myStack = document.getElementById(`my-stack-${i}`);
                const myProtocol = gameState.myProtocols[i];
                
                // Check if card can be played face-up to this line
                const canPlayFaceUp = selectedCard.protocol === myProtocol;
                
                // Highlight stacks
                myStack.style.outline = canPlayFaceUp ? '2px solid #00ff88' : '2px dashed #ffaa00';
                myStack.style.outlineOffset = '5px';
                myStack.style.cursor = 'pointer';
                
                // Add tooltip
                myStack.title = canPlayFaceUp ? 
                    `Click to play ${selectedCard.protocol} to ${myProtocol} line (can play face-up or face-down)` : 
                    `Click to play to ${myProtocol} line (face-down only - wrong protocol)`;
                
                // Add click handler
                myStack.onclick = () => playToLine(i);
            }
            
            // Show instruction
            showMessage('Click a stack (area below your protocols) to play the card there', 'info');
        }
        
        function playToLine(lineIndex) {
            if (!selectedCard || selectedCardIndex === null) return;
            
            // Ask for face up/down
            const playOptions = document.createElement('div');
            playOptions.className = 'play-options-modal';
            playOptions.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid #00ff88; border-radius: 10px;">
                    <h3>Play ${selectedCard.protocol.toUpperCase()} ${selectedCard.value}</h3>
                    <p>Choose how to play this card to line ${lineIndex + 1}:</p>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="confirmPlay(${lineIndex}, false)" style="flex: 1;">
                            Face Up<br><small>(Reveal effects)</small>
                        </button>
                        <button onclick="confirmPlay(${lineIndex}, true)" style="flex: 1;">
                            Face Down<br><small>(Hidden)</small>
                        </button>
                        <button onclick="cancelPlay()" style="flex: 1; background: rgba(255,0,0,0.2);">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            playOptions.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1000;
            `;
            document.body.appendChild(playOptions);
        }
        
        function confirmPlay(lineIndex, faceDown) {
            // Remove modal
            document.querySelector('.play-options-modal')?.remove();
            
            // Clear highlights
            clearLineSelection();
            
            // Play the card
            const card = selectedCard;
            card.faceDown = faceDown;
            
            // Check if playing face-up to correct protocol
            if (!faceDown) {
                const myProtocol = gameState.myProtocols[lineIndex];
                if (card.protocol !== myProtocol) {
                    showMessage(`Can't play ${card.protocol} face-up to ${myProtocol} line!`, 'error');
                    cancelPlay();
                    return;
                }
            }
            
            // Track last played card position
            lastPlayedCard = {
                lineIndex: lineIndex,
                stackIndex: gameState.field[lineIndex].myStack.length, // Will be the index after adding
                isOpponent: false
            };
            
            // Remove from hand and add to field
            gameState.myHand.splice(selectedCardIndex, 1);
            gameState.field[lineIndex].myStack.push(card);
            
            // Send to opponent
            if (conn && conn.send) {
                conn.send({
                    type: 'playCard',
                    lineIndex: lineIndex,
                    card: faceDown ? { faceDown: true, value: 0 } : card
                });
            }
            
            // Clear selection
            selectedCard = null;
            selectedCardIndex = null;
            
            updateUI();
            showMessage(`Played card to line ${lineIndex + 1}`, 'success');
        }
        
        function cancelPlay() {
            document.querySelector('.play-options-modal')?.remove();
            clearLineSelection();
            selectedCard = null;
            selectedCardIndex = null;
            
            // Clear card highlights
            document.querySelectorAll('.hand .card').forEach(c => {
                c.style.border = '';
            });
        }
        
        function clearLineSelection() {
            // Clear stack highlights
            for (let i = 0; i < 3; i++) {
                const myStack = document.getElementById(`my-stack-${i}`);
                myStack.style.outline = '';
                myStack.style.cursor = '';
                myStack.onclick = null;
                myStack.title = '';
            }
        }
        
        function showMessage(text, type = 'info') {
            const existing = document.getElementById('game-message');
            if (existing) existing.remove();
            
            const message = document.createElement('div');
            message.id = 'game-message';
            message.textContent = text;
            message.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px 20px;
                background: ${type === 'error' ? 'rgba(255,0,0,0.2)' : type === 'success' ? 'rgba(0,255,0,0.2)' : 'rgba(0,255,136,0.2)'};
                border: 2px solid ${type === 'error' ? '#ff4444' : '#00ff88'};
                color: ${type === 'error' ? '#ff4444' : '#00ff88'};
                border-radius: 5px;
                z-index: 999;
                font-weight: bold;
            `;
            document.body.appendChild(message);
            
            setTimeout(() => message.remove(), 3000);
        }

        function handleOpponentPlayCard(data) {
            const card = data.card;
            
            // Track last played card position
            lastPlayedCard = {
                lineIndex: data.lineIndex,
                stackIndex: gameState.field[data.lineIndex].oppStack.length, // Will be the index after adding
                isOpponent: true
            };
            
            gameState.field[data.lineIndex].oppStack.push(card);
            gameState.opponentHandCount--;
            updateUI();
        }

        function refreshHand() {
            if (gameState.currentTurn !== 'me') return;
            if (gameState.myHand.length >= 5) return;
            
            while (gameState.myHand.length < 5 && gameState.myDeck.length > 0) {
                gameState.myHand.push(gameState.myDeck.shift());
            }
            
            // If deck is empty, shuffle trash
            if (gameState.myHand.length < 5 && gameState.myTrash.length > 0) {
                gameState.myDeck = shuffle([...gameState.myTrash]);
                gameState.myTrash = [];
                
                while (gameState.myHand.length < 5 && gameState.myDeck.length > 0) {
                    gameState.myHand.push(gameState.myDeck.shift());
                }
            }
            
            conn.send({ type: 'refreshHand' });
            updateUI();
        }

        function endTurn() {
            if (gameState.currentTurn !== 'me') return;
            
            gameState.currentTurn = 'opponent';
            
            // Clear last played card after a delay
            setTimeout(() => {
                lastPlayedCard = null;
                updateUI();
            }, 3000);
            
            conn.send({ type: 'endTurn' });
            updateUI();
        }

        function checkCompileConditions() {
            // Show or hide compile buttons based on turn
            for (let i = 0; i < 3; i++) {
                const myProtocol = document.getElementById(`my-protocol-${i}`);
                const existingBtn = document.getElementById(`compile-btn-${i}`);
                
                if (gameState.currentTurn === 'me' && !myProtocol.classList.contains('compiled')) {
                    // Add compile button if not exists
                    if (!existingBtn) {
                        const compileBtn = document.createElement('button');
                        compileBtn.id = `compile-btn-${i}`;
                        compileBtn.textContent = 'COMPILE?';
                        compileBtn.style.cssText = `
                            position: absolute;
                            bottom: -28px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: rgba(0, 0, 0, 0.8);
                            color: #00ff88;
                            border: 1px solid rgba(0, 255, 136, 0.5);
                            padding: 3px 8px;
                            border-radius: 3px;
                            font-weight: normal;
                            cursor: pointer;
                            z-index: 10;
                            font-size: 10px;
                            opacity: 0.7;
                            transition: all 0.3s;
                        `;
                        compileBtn.onmouseover = (e) => {
                            e.target.style.opacity = '1';
                            e.target.style.background = 'rgba(0, 255, 136, 0.2)';
                        };
                        compileBtn.onmouseout = (e) => {
                            e.target.style.opacity = '0.7';
                            e.target.style.background = 'rgba(0, 0, 0, 0.8)';
                        };
                        compileBtn.onclick = () => attemptCompile(i);
                        compileBtn.title = 'Attempt to compile this protocol (need 10+ and beat opponent)';
                        myProtocol.parentElement.style.position = 'relative';
                        myProtocol.parentElement.appendChild(compileBtn);
                    }
                } else {
                    // Remove button if it's not player's turn or already compiled
                    if (existingBtn) existingBtn.remove();
                }
            }
        }
        
        function attemptCompile(lineIndex) {
            if (gameState.currentTurn !== 'me') return;
            
            const myValue = calculateLineValue(gameState.field[lineIndex].myStack);
            const oppValue = calculateLineValue(gameState.field[lineIndex].oppStack);
            
            if (myValue >= 10 && myValue > oppValue) {
                // Success! Delete all cards in this line
                gameState.myTrash.push(...gameState.field[lineIndex].myStack);
                gameState.field[lineIndex].myStack = [];
                gameState.field[lineIndex].oppStack = [];
                
                // Flip protocol to compiled
                const myProtocol = document.getElementById(`my-protocol-${lineIndex}`);
                myProtocol.classList.remove('loading');
                myProtocol.classList.add('compiled');
                
                // Send compile action to opponent
                if (conn && conn.send) {
                    conn.send({
                        type: 'compileLine',
                        lineIndex: lineIndex
                    });
                }
                
                showMessage(`Successfully compiled ${gameState.myProtocols[lineIndex]}!`, 'success');
                
                // Check for victory
                checkVictory();
                
                updateUI();
            } else {
                // Failed compile attempt
                if (myValue < 10) {
                    showMessage(`Compile failed! You only have ${myValue} value (need 10+)`, 'error');
                } else {
                    showMessage(`Compile failed! Your ${myValue} doesn't beat opponent's ${oppValue}`, 'error');
                }
            }
        }
        
        function checkVictory() {
            const compiledCount = document.querySelectorAll('.protocol.compiled#my-protocol-0, .protocol.compiled#my-protocol-1, .protocol.compiled#my-protocol-2').length;
            
            if (compiledCount === 3) {
                showMessage('YOU WIN! All protocols compiled!', 'success');
                document.getElementById('turn-indicator').textContent = 'VICTORY!';
                document.getElementById('turn-indicator').style.color = '#00ff88';
                document.getElementById('refresh-btn').disabled = true;
                document.getElementById('end-turn-btn').disabled = true;
                document.getElementById('count-btn').disabled = true;
            }
        }

        function countValues() {
            // Manual count - show values temporarily
            for (let i = 0; i < 3; i++) {
                const myValue = calculateLineValue(gameState.field[i].myStack);
                const oppValue = calculateLineValue(gameState.field[i].oppStack);
                
                const lineLabel = document.querySelector(`.line[data-line="${i}"] .line-label`);
                if (lineLabel) {
                    const originalText = lineLabel.innerHTML;
                    lineLabel.innerHTML = `Line ${i + 1}<br><small style="color: #00ff88;">You: ${myValue} | Opp: ${oppValue}</small>`;
                    
                    // Reset after 3 seconds
                    setTimeout(() => {
                        lineLabel.innerHTML = `Line ${i + 1}`;
                    }, 3000);
                }
            }
            
            showMessage('Values shown for 3 seconds', 'info');
        }
        
        function calculateLineValue(stack) {
            return stack.reduce((sum, card) => {
                // Face-down cards have value 0
                if (card.faceDown) return sum;
                // Face-up cards add their value
                return sum + (card.value || 0);
            }, 0);
        }

        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Make functions globally available for button onclick handlers
        window.confirmPlay = confirmPlay;
        window.cancelPlay = cancelPlay;
        window.moveCard = moveCard;
        window.refreshHand = refreshHand;
        window.countValues = countValues;
        window.endTurn = endTurn;
        window.connectToPeer = connectToPeer;
        window.copyId = copyId;
        window.useLocalMode = useLocalMode;
    </script>
</body>
</html>
